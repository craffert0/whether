#! /usr/bin/env python3

# SPDX-License-Identifier: GPL-2.0-or-later
# Copyright (C) 2025 Colin Rafferty <colin@rafferty.net>

# There must be a ~/.whetherrc file like this:
#
#   {
#     "auth": "eyJhb...",
#     "lat": 40.674942,
#     "long": -73.969016
#     "country": "US"
#   }
#
# The "country" entry is optional, and defaults to US. The "auth" entry is an
# authentication token generated from Apple. Here are two blogposts about how
# to generate it:
#
# https://dev.iachieved.it/iachievedit/weatherkit-rest-api/
# https://mrhemanth.medium.com/how-to-use-apples-weatherkit-to-fetch-weather-data-8c4c27826f7d

import datetime
import json
import os.path
import re

from http.client import *
from pathlib import Path


class Server:
    def __init__(self):
        rc = json.loads(Path(os.path.expanduser("~/.whetherrc")).read_text())
        self.headers = {"Authorization": f'Bearer {rc["auth"]}'}
        self.latlong = f'{rc["lat"]}/{rc["long"]}'
        if "country" in rc:
            self.country = "country=" + rc["country"]
        else:
            self.country = "country=US"
        self.conn = HTTPSConnection("weatherkit.apple.com")

    def get(self, path, params=""):
        fullpath = "/api/v1/" + path + "/" + self.latlong
        fullparams = self.country + params
        req = self.conn.request(
            "GET", f"{fullpath}?{fullparams}", headers=self.headers
        )
        response = self.conn.getresponse()
        if response.status != 200:
            raise RuntimeError(f"{response.status}: {response.reason}")
        return json.loads(response.read())

    def weather(self, dataSets):
        return self.get("weather/en_US", f'&dataSets={",".join(dataSets)}')


def cToF(celsius):
    return int(32 + celsius * 1.8)


def uncamel(s):
    return " ".join(
        [
            x.lower()
            for x in re.findall(r"[A-Z](?:[a-z]+|[A-Z]*(?=[A-Z]|$))", s)
        ]
    )


def currentWeather(js):
    print(
        f'now: {uncamel(js["conditionCode"])}: {cToF(js["temperature"])}째 ({cToF(js["temperatureApparent"])}째)'
    )


def shortCondition(s):
    chance = s["precipitationChance"]
    if chance == 0:
        return s["condition"]
    return f'{int(100 * chance)}% chance {s["condition"]}'


def getTime(s, n):
    str = s.get(n)
    return None if str == None else datetime.datetime.fromisoformat(str)


def deltaMinutes(x, y):
    return int((x - y) / datetime.timedelta(minutes=1))


def shortTag(now, i, s):
    endTime = getTime(s, "endTime")
    if endTime != None:
        if i == 0:
            return f"next {deltaMinutes(endTime, now)} minutes"
        else:
            return f'following {deltaMinutes(endTime, getTime(s, "startTime"))} minutes'
    elif i == 0:
        return "next hour"
    else:
        return f'remaining {60 - deltaMinutes(getTime(s, "startTime"), now)} minutes'


def forecastNextHour(js):
    now = datetime.datetime.now(datetime.timezone.utc)
    for i, s in enumerate(js["summary"]):
        print(f"{shortTag(now, i, s)}: {shortCondition(s)}")


def forecastDaily(js):
    r = js["days"][0]["restOfDayForecast"]
    print(
        f'today: {uncamel(r["conditionCode"])}: {cToF(r["temperatureMax"])}째/{cToF(r["temperatureMin"])}째'
    )


def weatherAlerts(js):
    # {
    #     "name": "WeatherAlertSummary",
    #     "id": "7c891503-e71a-50fd-abf5-c9dffa8d3ca0",
    #     "areaId": "nyz075",
    #     "attributionURL": "https://www.weather.gov",
    #     "countryCode": "US",
    #     "description": "Special Weather Statement",
    #     "token": "SPECIAL_WEATHER_STATEMENT",
    #     "effectiveTime": "2025-03-26T20:06:00Z",
    #     "expireTime": "2025-03-27T23:00:00Z",
    #     "issuedTime": "2025-03-26T20:06:00Z",
    #     "eventOnsetTime": "2025-03-26T20:06:00Z",
    #     "detailsUrl": "https://weatherkit.apple.com/alertDetails/index.html?ids=7c891503-e71a-50fd-abf5-c9dffa8d3ca0&lang=en-US&timezone=America/New_York",
    #     "phenomenon": "Other",
    #     "precedence": 0,
    #     "severity": "moderate",
    #     "source": "National Weather Service",
    #     "eventSource": "US",
    #     "urgency": "expected",
    #     "certainty": "observed",
    #     "importance": "normal",
    #     "responses": [
    #         "execute"
    #     ]
    # }
    for a in js["alerts"]:
        print(json.dumps(a, indent=2))


# forecastHourly


def dumpAll(server):
    print(json.dumps(server.weather(server.get("availability")), indent=2))


def main():
    server = Server()
    results = server.weather(
        [
            "currentWeather",
            "forecastNextHour",
            "forecastDaily",
            # "weatherAlerts",
        ]
    )
    currentWeather(results["currentWeather"])
    forecastNextHour(results["forecastNextHour"])
    forecastDaily(results["forecastDaily"])
    # weatherAlerts(results["weatherAlerts"])


if __name__ == "__main__":
    main()
